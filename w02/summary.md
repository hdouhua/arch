02周总结
===

编程的过程：在计算机所能理解的“模型”（解空间）和现实世界（问题空间）之间，建立一种联系。

### 面向对象编程（OOP）

万物皆对象！

对象：具有状态、行为和标识

#### 三要素

- 封装（encapsulation）
  - 隐藏实现细节（访问控制）
  - 定义接口
- 继承（inheritance）
  - IS-A关系
  - HAS-A关系（组合）
- 多态（polymorphism）
  - 后期绑定（虚方法）
  - 向上转型（up casting）

这三个特性都不是面向对象编程独有的。

>  面向对象编程不是使用面向对象的语言编程，而是利用多态特性进行编程。

### 面向对象分析（OOA）

业务领域进行对象分析

### 面向对象设计（OOD）

目的：强内聚、松耦合

基于以上目的使系统：

- 易扩展：增加功能

- 更健壮：

- 可移植：多样化的运行环境

- 更简单：易理解、易维护

### 框架vs工具

框架：实现某一类应用的结构性程序，是对某一类架构方案可复用的设计与实现

常见框架：TBD

框架调用应用程序代码，应用程序代码调用工具

架构师用框架保证架构的落地，用工具提高开发效率

### 案例

寻找对象 -> 寻找名词

理解面向对象编程

### 面向对象设计原则

1. OCP open-close principle 开闭原则

   对扩展开放，对修改关闭

   不需要修改软件实体（类、模块、函数等），就可以实现功能的扩展 ——关键是抽象

   实现OCP的关键在于抽象，而抽象的威力在于多态和继承

2. DIP depnedency inversion principle 依赖倒置原则

   高层模块不应依赖低层模块，都依赖于抽象

   抽象不依赖实现，而是实现依赖抽象

   倒置了什么？

   - 倒置了模块或包的依赖关系

   - 开发顺序和职责
     - 高层决定低层
     - 高层被复用

3. LSP Liskov substitution principle 李氏置换原则

   派生类（子类）对象可以在程序中代替其基类（超类/父类）对象。

   一个正确的继承要符合什么要求？——LSP

   #### 违反LSP的例子，为什么正方形IS-NOT-A长方形？

   - 标识：不同

   - 状态：不同

   - 行为：相同

    ——设计和界定一个类，应该以其行为来区分。

   从契约的角度看

   凡是使用父类的地方，可以用子类替代

   => 子类的契约不能比父类更严格

   => 正方形不可以是长方形的子类

   #### 重构代码，解决LSP问题

   - 提取共性到基类

   - 改继承为组合

     继承 vs 组合

     - OOP的两种扩展手段

     - 继承的优点

       - 容易实现

     - 继承的缺点

       - 破坏了封装

       - 继承关系是静态的

       - 类层级爆炸

     ——优先使用组合

   #### 何时检测LSP？

避免“过于复杂”或“过度设计”，只预测明显违反LSP的情况，推迟其它的预测。
   
4. SRP single responsibility principle 接口隔离原则

   - 被称为“内聚性原则”（cohesion）——一个模块的组成元素之间的功能相关性

   - 一个类只能有一个引起它变化的原因

   这个类的职责其实还是比较需要度来把握是否需要拆分

5. ISP interface segregation principle 接口隔离原则

   - 不应该强迫客户程序依赖它们不需要的方法。

   - 内聚性相关原则
   - 从客户的需求出发，强调不要让客户看到他们不需要的方法

### 老师推荐书籍

[《敏捷软件开发—原则、模式与实践》](https://item.jd.com/10078483.html)


架构师角度是技术优先，公司角度是业务优先，架构师需要多元化思考，找到一个权衡点

### 扩展——反应式编程

#### Flower框架

使用了[Akka](https://akka.io/)框架

#### 个人扩展

去学习了 actor model in .net [akka.net](https://getakka.net/)
